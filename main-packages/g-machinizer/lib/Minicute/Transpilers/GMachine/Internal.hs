{-# OPTIONS_HADDOCK hide #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE OverloadedStrings #-}
-- |
-- Copyright: (c) 2018-present Junyoung Clare Jang
-- License: BSD 3-Clause
--
-- Implementation detail of the transpiler from a miniCUTE program to a G-Machine program
module Minicute.Transpilers.GMachine.Internal
  ( transpileProgram

  , initialCode
  ) where

import Control.Lens.Each
import Control.Lens.Operators
import Control.Lens.Wrapped ( _Wrapped )
import Data.List
import Data.String
import Minicute.Data.GMachine.Instruction
import Minicute.Data.Minicute.Program

import qualified Data.Map as Map

-- * Transpilers
-- ** Calling Convention

-- $callingConvention
-- Which calling convention we gonna use?
--
-- 1. Try simple one
--
--     1. caller
--
--         - Push arguments in caller
--         - Evaluate result in caller
--
--     1. callee
--
--         - Update results in callee
--         - Pop arguments in callee

-- ** Transpiler Functions
-- *** Transpilers for a Program

-- |
-- Transpiler for a __Program__.
transpileProgram :: MainProgram t 'LLMC -> GMachineProgram
transpileProgram program = transpileSc <$> program ^. _Wrapped
{-# INLINABLE transpileProgram #-}

-- |
-- Transpiler for a __S__uper__c__ombinator (top-level function definition).
transpileSc :: MainSupercombinator t 'LLMC -> GMachineSupercombinator
transpileSc sc = (scBinder, scArgsLength, scInsts)
  where
    scBinder = sc ^. _supercombinatorBinder

    scInsts = transpileRE scArgsEnv $ sc ^. _supercombinatorBody

    scArgsEnv = Map.fromList $ zip scArgs [0..]
    scArgsLength = length scArgs
    scArgs = sc ^. _supercombinatorArguments

    {-# INLINABLE scBinder #-}
    {-# INLINABLE scInsts #-}
    {-# INLINABLE scArgsEnv #-}
    {-# INLINABLE scArgsLength #-}
{-# INLINABLE transpileSc #-}

-- *** Transpilers for an Expression
-- |
-- Transpiler for a __R__oot __E__xpression.
transpileRE :: TranspilerE (MainExpression t 'LLMC)
transpileRE env (EInteger _ n)
  = [ IPushBasicValue n
    , IUpdateAsInteger (getEnvSize env)
    , IReturn
    ]
transpileRE env (EConstructor _ tag 0)
  = [ IPushBasicValue tag
    , IUpdateAsStructure (getEnvSize env)
    , IReturn
    ]
transpileRE env e@(EApplication2 _ _ (EPrimitive _ prim) _ _)
  | Just _ <- lookup prim binaryPrimitivePrecedenceTable
  = transpilePE env e
    <>
    [ IUpdateAsInteger (getEnvSize env)
    , IReturn
    ]
transpileRE env (ELet _ flag lDefs body)
  = transpileLet transpileRE env (flag, lDefs, body)
transpileRE env (EMatch _ body mCases)
  = transpileMatch transpileSE (const transpileRE) env (body, mCases)
-- Should following really use a strict expression?
transpileRE env e
  = transpileSE env e
    <>
    [ IUpdate envSize1
    , IPop envSize1
    , IUnwind
    ]
  where
    envSize1 = getEnvSize env + 1

-- |
-- Transpiler for a __S__trict __E__xpression.
-- All instruction generated by this transpiler should put the address of a whnf node on the top of the stack.
--
-- This transpiler is not able to directly transpile variable expressions because value of variable can be a non-whnf node.
transpileSE :: TranspilerE (MainExpression t 'LLMC)
transpileSE _ (EInteger _ n)
  = [ IMakeInteger n
    ]
transpileSE _ (EConstructor _ tag 0)
  = [ IMakeStructure tag 0
    ]
transpileSE _ (EConstructor _ tag arity)
  = [ IMakeConstructor tag arity
    ]
transpileSE env e@(EApplication2 _ _ (EPrimitive _ prim) _ _)
  | Just _ <- lookup prim binaryPrimitivePrecedenceTable
  = transpilePE env e
    <>
    [ IWrapAsInteger
    ]
transpileSE env e
  = transpileNE env e
    <>
    [ IEval
    ]

-- |
-- Transpiler for a __P__rimitive __E__xpression.
-- All instruction generated by this transpiler should put a primitive value on the top of the value stack.
transpilePE :: TranspilerE (MainExpression t 'LLMC)
transpilePE _ (EInteger _ n)
  = [ IPushBasicValue n
    ]
transpilePE _ (EConstructor _ tag 0)
  = [ IPushBasicValue tag
    ]
transpilePE env (EApplication2 _ _ (EPrimitive _ prim) e1 e2)
  | Just _ <- lookup prim binaryPrimitivePrecedenceTable
  = transpilePE env e1
    <> transpilePE env e2
    <>
    [ IPrimitive prim
    ]
transpilePE env (ELet _ flag lDefs body)
  = transpileLet transpilePE env (flag, lDefs, body)
    <>
    [ IPop (length lDefs)
    ]
transpilePE env e
  = transpileSE env e
    <>
    [ IPushExtractedValue
    ]

-- |
-- Transpiler for a __N__on-strict __E__xpression.
-- All instruction generated by this transpiler should put the address of a node on the top of the stack.
transpileNE :: TranspilerE (MainExpression t 'LLMC)
transpileNE _ (EInteger _ n)
  = [ IMakeInteger n
    ]
transpileNE _ (EConstructor _ tag 0)
  = [ IMakeStructure tag 0
    ]
transpileNE _ (EConstructor _ tag arity)
  = [ IMakeConstructor tag arity
    ]
transpileNE env (EVariable _ v)
  | Just index <- Map.lookup v env
  = [ ICopy index
    ]
  | otherwise
  = [ IMakeGlobal v
    ]
transpileNE _ (EPrimitive _ prim)
  = [ IMakeGlobal $ (fromString . toString) prim
    ]
transpileNE env (EApplication _ e1 e2)
  = transpileNE env e1
    <> transpileNE (addEnvOffset1 env) e2
    <>
    [ IMakeApplication
    ]
transpileNE env (ELet _ flag lDefs body)
  = transpileLet transpileNE env (flag, lDefs, body)
    <>
    [ IDig (length lDefs)
    ]
transpileNE _ _ = error "Not yet implemented"

-- *** Transpilers for others
-- |
-- Transpiler for a __Let__ expression.
transpileLet :: TranspilerE (MainExpression t 'LLMC) -> TranspilerE (IsRecursive, [MainLetDefinition t 'LLMC], MainExpression t 'LLMC)
transpileLet transpileBody env (flag, lDefs, body)
  | isRecursive flag
  = transpileLetRecDefs env' lDefs
    <> bodyInst
  | otherwise
  = transpileLetDefs env lDefs
    <> bodyInst
  where
    bodyInst = transpileBody env' body
    env' = updateLetEnv lDefs env

    {-# INLINE bodyInst #-}
    {-# INLINABLE env' #-}

transpileLetDefs :: TranspilerE [MainLetDefinition t 'LLMC]
transpileLetDefs env lDefs
  = concat (zipWith transpileNE envs lDefsBodies)
  where
    envs = iterate addEnvOffset1 env
    lDefsBodies = lDefs ^.. each . _letDefinitionBody

    {-# INLINABLE envs #-}
    {-# INLINABLE lDefsBodies #-}
{-# INLINABLE transpileLetDefs #-}

transpileLetRecDefs :: TranspilerE [MainLetDefinition t 'LLMC]
transpileLetRecDefs env lDefs
  = [ IMakePlaceholders len
    ]
    <> concatMap ((<> [IUpdate len]) . transpileNE env) lDefsBodies
  where
    lDefsBodies = lDefs ^.. each . _letDefinitionBody
    len = length lDefs

    {-# INLINABLE lDefsBodies #-}
    {-# INLINE len #-}
{-# INLINABLE transpileLetRecDefs #-}

updateLetEnv :: [MainLetDefinition t 'LLMC] -> TranspilerEEnv -> TranspilerEEnv
updateLetEnv lDefs env
  = envOfLDefs
    <> addEnvOffset len env
  where
    envOfLDefs = Map.fromList (zip lDefsBinders [len - 1, len - 2 .. 0])
    lDefsBinders = lDefs ^.. each . _letDefinitionBinder
    len = length lDefs

    {-# INLINABLE envOfLDefs #-}
    {-# INLINABLE lDefsBinders #-}
    {-# INLINE len #-}
{-# INLINABLE updateLetEnv #-}

-- |
-- Transpiler for a __Match__ expression.
transpileMatch :: TranspilerE (MainExpression t l) -> (Integer -> TranspilerE (MainExpression t l)) -> TranspilerE (MainExpression t l, [MainMatchCase t l])
transpileMatch transpileBody transpileCase env (body, mCases)
  = bodyInst
    <>
    [ IMatch (makeMatchTable transpileCase env mCases)
    ]
  where
    bodyInst = transpileBody env body

    {-# INLINE bodyInst #-}
{-# INLINABLE transpileMatch #-}

makeMatchTable :: (Integer -> TranspilerE (MainExpression t l)) -> TranspilerEEnv -> [MainMatchCase t l] -> MatchTable
makeMatchTable transpileCase env
  = MatchTable . fmap (makeMatchEntry transpileCase env)
{-# INLINABLE makeMatchTable #-}

makeMatchEntry :: (Integer -> TranspilerE (MainExpression t l)) -> TranspilerEEnv -> MainMatchCase t l -> MatchEntry
makeMatchEntry transpileCase env mCase
  = MatchEntry (caseTag, caseInst)
  where
    caseInst
      = [ IDestruct caseArgsLen
        ]
        <> transpileCase caseArgsLen env' caseBody
    caseBody = mCase ^. _matchCaseBody
    caseTag = mCase ^. _matchCaseTag

    env'
      = Map.fromList (zip caseArgs [0..])
        <> addEnvOffset (fromInteger caseArgsLen) env

    caseArgsLen = genericLength caseArgs
    caseArgs = mCase ^. _matchCaseArguments

    {-# INLINE caseInst #-}
    {-# INLINE caseBody #-}
    {-# INLINE caseTag #-}
    {-# INLINABLE env' #-}
    {-# INLINABLE caseArgsLen #-}
    {-# INLINABLE caseArgs #-}
{-# INLINABLE makeMatchEntry #-}

-- ** Types
-- |
-- A transpiler that uses 'TranspilerEEnv' and @a@ to build 'GMachineExpression'
type TranspilerE a = TranspilerEEnv -> a -> GMachineExpression

-- |
-- Environment type used for expression transpilers
type TranspilerEEnv = Map.Map Identifier Int

getEnvSize :: TranspilerEEnv -> Int
getEnvSize = Map.size
{-# INLINE getEnvSize #-}

addEnvOffset1 :: TranspilerEEnv -> TranspilerEEnv
addEnvOffset1 = fmap (+ 1)
{-# INLINE addEnvOffset1 #-}

addEnvOffset :: Int -> TranspilerEEnv -> TranspilerEEnv
addEnvOffset n = fmap (+ n)
{-# INLINE addEnvOffset #-}


-- * Initial Instructions
-- |
-- Initial instructions used to start any program.
initialCode ::[Instruction]
initialCode = [IMakeGlobal "main", IEval]
{-# INLINE initialCode #-}
